import { describe, it, expect, Mocked } from 'vitest';
import { FormatterAdapter, MarkdownFormatterAdapter, RepositoryProvider, SectionIdentifier } from '@ci-dokumentor/core';
import { initTestContainer } from '@ci-dokumentor/repository-github';
import { RepositoryInfoMockFactory, RepositoryProviderMockFactory } from '@ci-dokumentor/core/tests';
import { GitHubAction } from '../github-actions-parser.js';
import { GitHubActionMockFactory } from '../../__tests__/github-action-mock.factory.js';
import { GitHubWorkflowMockFactory } from '../../__tests__/github-workflow-mock.factory.js';
import { GeneratedSectionGenerator } from './generated-section-generator.adapter.js';

describe('GeneratedSectionGenerator', () => {
  let mockRepositoryProvider: Mocked<RepositoryProvider>;
  let formatterAdapter: FormatterAdapter;

  let generator: GeneratedSectionGenerator;

  beforeEach(() => {
    vi.resetAllMocks();

    mockRepositoryProvider = RepositoryProviderMockFactory.create({
      getRepositoryInfo: RepositoryInfoMockFactory.create(),
    });

    const container = initTestContainer();
    formatterAdapter = container.get(MarkdownFormatterAdapter);

    generator = new GeneratedSectionGenerator();
  });

  afterEach(() => {
    vi.resetAllMocks();
  });

  describe('getSectionIdentifier', () => {
    it('should return Generated section identifier', () => {
      // Act
      const result = generator.getSectionIdentifier();

      // Assert
      expect(result).toBe(SectionIdentifier.Generated);
    });
  });

  describe('generateSection', () => {
    it('should generate "generated by" section with link to CI Dokumentor', async () => {
      // Arrange
      const manifest: GitHubAction = GitHubActionMockFactory.create();

      // Act
      const result = await generator.generateSection({ formatterAdapter, manifest, repositoryProvider: mockRepositoryProvider, destination: 'README.md' });

      // Assert

      expect(result.toString()).toEqual(`---

This documentation was automatically generated by [CI Dokumentor](https://github.com/hoverkraft-tech/ci-dokumentor).
`);
    });

    it('should generate the same section regardless of manifest type', async () => {
      // Arrange
      const actionManifest: GitHubAction = GitHubActionMockFactory.create();
      const workflowManifest = GitHubWorkflowMockFactory.create();

      // Act
      const actionResult = await generator.generateSection({ formatterAdapter, manifest: actionManifest, repositoryProvider: mockRepositoryProvider, destination: 'README.md' });
      const workflowResult = await generator.generateSection({ formatterAdapter, manifest: workflowManifest, repositoryProvider: mockRepositoryProvider, destination: 'README.md' });

      // Assert
      expect(actionResult.toString()).toEqual(workflowResult.toString());
      expect(actionResult.toString()).toEqual(`---

This documentation was automatically generated by [CI Dokumentor](https://github.com/hoverkraft-tech/ci-dokumentor).
`);
    });

    it('should generate the same section regardless of repository', async () => {
      // Arrange
      const manifest: GitHubAction = GitHubActionMockFactory.create();

      const alternativeRepositoryProvider = RepositoryProviderMockFactory.create({
        getRepositoryInfo: RepositoryInfoMockFactory.create({
          url: 'https://github.com/different-owner/different-repo',
          owner: 'different-owner',
          name: 'different-repo',
          fullName: 'different-owner/different-repo',
        }),
      });

      // Act
      const result1 = await generator.generateSection({ formatterAdapter, manifest, repositoryProvider: mockRepositoryProvider, destination: 'README.md' });
      const result2 = await generator.generateSection({ formatterAdapter, manifest, repositoryProvider: alternativeRepositoryProvider, destination: 'README.md' });

      // Assert
      expect(result1.toString()).toEqual(result2.toString());
      expect(result1.toString()).toEqual(`---

This documentation was automatically generated by [CI Dokumentor](https://github.com/hoverkraft-tech/ci-dokumentor).
`);
    });
  });
});